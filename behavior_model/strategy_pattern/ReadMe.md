## 策略模式

策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

## 角色组成
- Context: 上下文类，用来操作策略的上下文环境
- Strategy: 抽象策略类，定义所有支持的算法的公共接口
- ConcreteStrategy: 具体策略类，实现Strategy接口的具体算法
- Client: 客户端，通过Context调用具体策略类
- 优点
  - 开闭原则。 你可以在不修改上下文的情况下引入新策略。
  - 你可以在运行时切换对象的策略。
  - 你可以通过继承Context类来改变上下文的行为。
  - 你可以将算法和其数据局部化。
  - 你可以对客户隐藏具体策略的实现细节。

## 应用场景
1. 当你有许多类似的类， 仅有行为有所不同时， 可使用策略模式。
2. 当你需要使用不同的算法变体时， 可使用该模式。
3. 当一个类定义了多种行为， 并且这些行为在这个类的操作中以多个条件语句的形式出现时， 可使用该模式。
4. 当你需要在运行时切换不同算法时， 可使用该模式。
5. 当你有一个类的某个行为会频繁发生变化， 且你希望将这些变化封装在独立的类中时， 可使用该模式。

## 示例
思考一下构建内存缓存的情形。 由于处在内存中， 故其大小会存在限制。 在达到其上限后， 一些条目就必须被移除以留出空间。 此类操作可通过多种算法进行实现。 一些流行的算法有：

最少最近使用 （LRU）： 移除最近使用最少的一条条目。
先进先出 （FIFO）： 移除最早创建的条目。
最少使用 （LFU）： 移除使用频率最低一条条目。
问题在于如何将我们的缓存类与这些算法解耦， 以便在运行时更改算法。 此外， 在添加新算法时， 缓存类不应改变。

这就是策略模式发挥作用的场景。 可创建一系列的算法， 每个算法都有自己的类。 这些类中的每一个都遵循相同的接口， 这使得系列算法之间可以互换。 假设通用接口名称为 evictionAlgo移除算法 。

现在， 我们的主要缓存类将嵌入至 evictionAlgo接口中。 缓存类会将全部类型的移除算法委派给 evictionAlgo接口， 而不是自行实现。 鉴于 evictionAlgo是一个接口， 我们可在运行时将算法更改为 LRU、 FIFO 或者 LFU， 而不需要对缓存类做出任何更改。